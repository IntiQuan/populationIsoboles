% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Isobole_gridRefinementAlgorithm.R
\name{fastIsoboles}
\alias{fastIsoboles}
\title{Grid refinement algorithm to calculate isoboles}
\usage{
fastIsoboles(
  objfun,
  objvalue = 0.95,
  gridmin = c(x = 0, y = 0),
  gridmax = c(x = 1, y = 1),
  imin = 5,
  imax = 7,
  FLAGverbose = FALSE,
  k = NULL,
  .outputFolder = NULL,
  areaterm = 1.01
)
}
\arguments{
\item{objfun}{Function(x,y) returning a vector of the same length with the corresponding objvalue values.
Combined with objvalue, this could be called the objective function}

\item{objvalue}{The value for which the contour lines are calculated. E.g. 0.95}

\item{gridmin}{General grid parameters: Vectors with names x and y c(x = 0, y = 0)}

\item{gridmax}{General grid parameters: Vectors with names x and y c(x = 0, y = 0)}

\item{imin, imax}{minimum/maximum number of iterations}

\item{FLAGverbose}{Print messages to the console}

\item{k}{index of population for outputting the current isobole iteration to the disk}

\item{.outputFolder}{Path to store results in. See \code{\link{output_gridrefinement_results}}}

\item{areaterm}{Terminate when the area above the curve (bounded by the grid) doesn't change more than this value (on relative scale)}
}
\value{
list with
  * grid: Exact objvalue values where the objvalue has been evaluated
  * path: The last isobole path
  * pathlist: The paths of all iterations
  * itermax: The number of iterations used
  * areas: The areas above the isobole (To analyze the convergence)
  * times: proc.time - stamps. The first entry is before iteration 0, the second is after iteration 1 etc.
}
\description{
Grid refinement algorithm to calculate isoboles
}
\examples{
library(populationIsoboles)
library(data.table)
library(ggplot2)

# Two drugs on different scales
objfun1 <- function(x,y) {sqrt((0.001)^2 * x^2 + (0.1)^2 * y^2)}
gridmin <- c(x = 0, y = 0) + 0.0001
gridmax <- c(x = 10*2^7, y = 0.1*2^7) + 0.0001

# Quick plot of function
testobjvalue = data.table(expand.grid(
  x = populationIsoboles:::seqminmax(
      gridmin["x"], gridmax["x"], (gridmax["x"] - gridmin["x"])/(2^6)),
  y = populationIsoboles:::seqminmax(
      gridmin["y"], gridmax["y"], (gridmax["y"] - gridmin["y"])/(2^6))))
testobjvalue[,`:=`(objvalue1 = objfun1(x,y))]
ggplot(testobjvalue, aes(x,y, z = objvalue1)) +
  geom_contour(aes(color = ..level..))

# Run algorithm
isobole <- fastIsoboles( objfun1,0.95,gridmin, gridmax, 5,7)
# Plot algo results
ggplot() + geom_tile(data = isobole$grid, aes(x,y,fill = objvalueCum)) +
  geom_path(data = isobole$pathlist[[5]], aes(xp,yp)) +
  geom_path(data = isobole$pathlist[[1]], aes(xp,yp), linetype = 2) +
  scale_fill_viridis_c()

# Plot grid iterations
grd <- copy(isobole$grid)
grd[,`:=`(objvalue0 = NULL, evaluated0 = NULL, objvalueCum = NULL, evaluatedCum = NULL)]
grd <- melt(grd,c("x", "y"), measure = patterns("^evaluated", "objvalue"),
            variable.name = "iteration", value.name = c("evaluated","objvalue"),
            variable.factor = FALSE)
grd[,`:=`(iteration = as.numeric(as.character(iteration)))]
grd <- grd[!is.na(objvalue)]
grd[evaluated == 0 ,`:=`(evaluated = NA)]
ggplot() +
  geom_tile(data = grd, aes(x,y,fill = factor(evaluated * iteration))) +
  geom_point(data = grd, aes(x,y,shape = factor(evaluated * iteration))) +
  geom_path(data = isobole$pathlist[[5]], aes(xp,yp))

# Run algorithm - different objvalue - Level
isobole <- fastIsoboles(objfun1, 0.5,gridmin, gridmax, 5,7)
# Plot algo results
ggplot() + geom_tile(data = isobole$grid, aes(x,y,fill = objvalueCum)) +
  geom_path(data = isobole$pathlist[[5]], aes(xp,yp)) + scale_fill_viridis_c()

# Run algorithm - lower imin
isobole <- fastIsoboles(objfun1,0.95, gridmin, gridmax, 3,7)
isobole$itermax
# Plot algo results
ggplot() + geom_tile(data = isobole$grid, aes(x,y,fill = objvalueCum)) +
  geom_path(data = isobole$pathlist[[3]], aes(xp,yp)) + scale_fill_viridis_c()

# Run algorithm - lower imin & imax
isobole <- fastIsoboles(objfun1,0.95, gridmin, gridmax, 3,3)
isobole$itermax
# Plot algo results
ggplot() + geom_tile(data = isobole$grid, aes(x,y,fill = objvalueCum)) +
  geom_path(data = isobole$pathlist[[3]], aes(xp,yp)) + scale_fill_viridis_c()

# Run algorithm - Different function
objfun2 <- function(x,y) {(x+500)*(y+5)/(80^2)}
isobole <- fastIsoboles(objfun2,0.95, gridmin, gridmax, 3,7)
isobole$itermax
# Plot algo results
ggplot() + geom_tile(data = isobole$grid, aes(x,y,fill = objvalueCum)) +
  geom_path(data = isobole$pathlist[[3]], aes(xp,yp)) + scale_fill_viridis_c()

}
\seealso{
Other Grid refinement functions for isoboles: 
\code{\link{arrange_isobole_internal}()},
\code{\link{fastIsoboles_iteration0}()},
\code{\link{fastIsoboles_iteration}()},
\code{\link{get_gridlens}()},
\code{\link{get_isobole_path}()}
}
\author{
Daniel Lill, IntiQuan \email{daniel.lill@intiquan.com}
}
\concept{Grid refinement functions for isoboles}
